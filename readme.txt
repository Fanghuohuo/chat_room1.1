//因为这里太单一了，需要添加额外的功能                                                   
//将这里的chat_message封装一下，添加更多自己想要的功能
//这里添加一个功能，在聊天的时候需要知道客户端的名字

//怎么实现？
//1 最原始的做法：把c的结构体搞成字节流发过去，最后再将字节流还原
//头文件定义在structHeader中

有什么问题？
1 可扩展性太差，当增加新的内容的时候，修改的内容非常多
2 当内容非常少的时候，发了一个大包，内容很多的时候又装不下，而且只支持c/c++
3 还有跨平台的问题，如果只用int，并不能保证是4字节，用int32_t去保证


//2 序列化的方法：假设服务器也是用c++写的
//使用序列化，将类存放到流里面，当对方接受到以后，再从流中重新
//提取出相应信息(反序列化)

相当于是读盘，可以在内存中序列化和反序列化
也可以在磁盘里，包括可以很灵活的定义类型
比如说如果用boost提供的序列化反序列化的过程
就可以直接用vector、deque这种很灵活的类型

1的16:50  将stringstream改成fstream就可以重定向到文件中

c_struct  不能动态扩充，每次都必须把数组填满
但是用序列化的方法就可以进行动态扩充

用c++ 序列化问题：
1 局限性，要求双方都必须是c++
2 携带额外信息，当发一个hello时，会有额外的信息

//3 json序列化（类似于先搞成idl，再去搞）
//json 是 key value对

优点：
1 可视化非常好，不用解析就可以直接打出来
2 跨语言

如果要做可视化的数据分析用json可以搞
比如说数据库的

和protobuf比较的缺点
1 包会大一些
2 解析没有proto快

//4 protobuf序列化
类似thrift
也是一样，通过string   和  占位符来确定信息的
比如
message myname {
    string name = 1;
    string good = 2;
}

Protocal.pb.h代替了structHeader.h提供的协议
即用protobuf提供的序列化代替了自己写的强转
proto3用了多线程，所以编译的时候要加上lpthread

这个name和good没啥用，只是方便理解的
也一样会有required和optional
在proto3 里面默认都是optional可选的

最后用protoc 编译
安全性高，不是通过抛出异常去解决问题，而是通过状态去处理
这样就不会说由于异常没有捕获而造成什么问题

看风格，google不喜欢异常
facebook喜欢异常

优点：
1 消息压缩率高：传递的额外内容会少
2 消息是文档化的
3 跨语言

现在是单线程程序

